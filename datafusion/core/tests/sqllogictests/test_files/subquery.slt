# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#############
## Subquery Tests
#############


#############
## Setup test data table
#############
# two tables for subquery
statement ok
CREATE TABLE t1(t1_id INT, t1_name TEXT, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4);

statement ok
CREATE TABLE t2(t2_id INT, t2_name TEXT, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3);

statement ok
CREATE EXTERNAL TABLE IF NOT EXISTS customer (
        c_custkey BIGINT,
        c_name VARCHAR,
        c_address VARCHAR,
        c_nationkey BIGINT,
        c_phone VARCHAR,
        c_acctbal DECIMAL(15, 2),
        c_mktsegment VARCHAR,
        c_comment VARCHAR,
) STORED AS CSV DELIMITER ',' WITH HEADER ROW LOCATION 'tests/tpch-csv/customer.csv';

statement ok
CREATE EXTERNAL TABLE IF NOT EXISTS orders (
        o_orderkey BIGINT,
        o_custkey BIGINT,
        o_orderstatus VARCHAR,
        o_totalprice DECIMAL(15, 2),
        o_orderdate DATE,
        o_orderpriority VARCHAR,
        o_clerk VARCHAR,
        o_shippriority INTEGER,
        o_comment VARCHAR,
) STORED AS CSV DELIMITER ',' WITH HEADER ROW LOCATION 'tests/tpch-csv/orders.csv';

statement ok
CREATE EXTERNAL TABLE IF NOT EXISTS lineitem (
        l_orderkey BIGINT,
        l_partkey BIGINT,
        l_suppkey BIGINT,
        l_linenumber INTEGER,
        l_quantity DECIMAL(15, 2),
        l_extendedprice DECIMAL(15, 2),
        l_discount DECIMAL(15, 2),
        l_tax DECIMAL(15, 2),
        l_returnflag VARCHAR,
        l_linestatus VARCHAR,
        l_shipdate DATE,
        l_commitdate DATE,
        l_receiptdate DATE,
        l_shipinstruct VARCHAR,
        l_shipmode VARCHAR,
        l_comment VARCHAR,
) STORED AS CSV DELIMITER ',' WITH HEADER ROW LOCATION 'tests/tpch-csv/lineitem.csv';

# in_subquery_to_join_with_correlated_outer_filter
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id + 12 in (
                           select t2.t2_id + 1 from t2 where t1.t1_int > 0
                       )
----
11 a 1
33 c 3
44 d 4

# not_in_subquery_to_join_with_correlated_outer_filter
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id + 12 not in (
                               select t2.t2_id + 1 from t2 where t1.t1_int > 0
                           )
----
22 b 2

# in subquery with two parentheses, see #5529
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id in ((
                       select t2.t2_id from t2
                  ))
----
11 a 1
22 b 2
44 d 4

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id in ((
                       select t2.t2_id from t2
                  ))
and t1.t1_int < 3
----
11 a 1
22 b 2

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id not in ((
                            select t2.t2_id from t2 where t2.t2_int = 3
                      ))
----
22 b 2
33 c 3

# VALUES in subqueries, see 6017
query I
select t1_id
from t1
where t1_int = (select max(i) from (values (1)) as s(i));
----
11

# aggregated_correlated_scalar_subquery
query TT
explain SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
logical_plan
Projection: t1.t1_id, __scalar_sq_2.SUM(t2.t2_int) AS t2_sum
--Left Join: t1.t1_id = __scalar_sq_2.t2_id
----TableScan: t1 projection=[t1_id]
----SubqueryAlias: __scalar_sq_2
------Projection: SUM(t2.t2_int), t2.t2_id
--------Aggregate: groupBy=[[t2.t2_id]], aggr=[[SUM(t2.t2_int)]]
----------TableScan: t2 projection=[t2_id, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, SUM(t2.t2_int)@1 as t2_sum]
--CoalesceBatchesExec: target_batch_size=8192
----HashJoinExec: mode=Partitioned, join_type=Left, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 1 })]
------CoalesceBatchesExec: target_batch_size=8192
--------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 4), input_partitions=4
----------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]
------ProjectionExec: expr=[SUM(t2.t2_int)@1 as SUM(t2.t2_int), t2_id@0 as t2_id]
--------AggregateExec: mode=FinalPartitioned, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int)]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 4), input_partitions=4
--------------AggregateExec: mode=Partial, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int)]
----------------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
11 3
22 1
33 NULL
44 3

# aggregated_correlated_scalar_subquery_with_cast
query TT
explain SELECT t1_id, (SELECT sum(t2_int * 1.0) + 1 FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
logical_plan
Projection: t1.t1_id, __scalar_sq_4.SUM(t2.t2_int * Float64(1)) + Int64(1) AS t2_sum
--Left Join: t1.t1_id = __scalar_sq_4.t2_id
----TableScan: t1 projection=[t1_id]
----SubqueryAlias: __scalar_sq_4
------Projection: SUM(t2.t2_int * Float64(1)) + Float64(1) AS SUM(t2.t2_int * Float64(1)) + Int64(1), t2.t2_id
--------Aggregate: groupBy=[[t2.t2_id]], aggr=[[SUM(CAST(t2.t2_int AS Float64)) AS SUM(t2.t2_int * Float64(1))]]
----------TableScan: t2 projection=[t2_id, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, SUM(t2.t2_int * Float64(1)) + Int64(1)@1 as t2_sum]
--CoalesceBatchesExec: target_batch_size=8192
----HashJoinExec: mode=Partitioned, join_type=Left, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 1 })]
------CoalesceBatchesExec: target_batch_size=8192
--------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 4), input_partitions=4
----------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]
------ProjectionExec: expr=[SUM(t2.t2_int * Float64(1))@1 + 1 as SUM(t2.t2_int * Float64(1)) + Int64(1), t2_id@0 as t2_id]
--------AggregateExec: mode=FinalPartitioned, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int * Float64(1))]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 4), input_partitions=4
--------------AggregateExec: mode=Partial, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int * Float64(1))]
----------------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]

query IR rowsort
SELECT t1_id, (SELECT sum(t2_int * 1.0) + 1 FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
11 4
22 2
33 NULL
44 4

# aggregated_correlated_scalar_subquery_with_extra_group_by_constant
query TT
explain SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id group by t2_id, 'a') as t2_sum from t1
----
logical_plan
Projection: t1.t1_id, __scalar_sq_6.SUM(t2.t2_int) AS t2_sum
--Left Join: t1.t1_id = __scalar_sq_6.t2_id
----TableScan: t1 projection=[t1_id]
----SubqueryAlias: __scalar_sq_6
------Projection: SUM(t2.t2_int), t2.t2_id
--------Aggregate: groupBy=[[t2.t2_id, Utf8("a")]], aggr=[[SUM(t2.t2_int)]]
----------TableScan: t2 projection=[t2_id, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, SUM(t2.t2_int)@1 as t2_sum]
--CoalesceBatchesExec: target_batch_size=8192
----HashJoinExec: mode=Partitioned, join_type=Left, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 1 })]
------CoalesceBatchesExec: target_batch_size=8192
--------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 4), input_partitions=4
----------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]
------CoalesceBatchesExec: target_batch_size=8192
--------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 1 }], 4), input_partitions=4
----------ProjectionExec: expr=[SUM(t2.t2_int)@2 as SUM(t2.t2_int), t2_id@0 as t2_id]
------------AggregateExec: mode=FinalPartitioned, gby=[t2_id@0 as t2_id, Utf8("a")@1 as Utf8("a")], aggr=[SUM(t2.t2_int)]
--------------CoalesceBatchesExec: target_batch_size=8192
----------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }, Column { name: "Utf8(\"a\")", index: 1 }], 4), input_partitions=4
------------------AggregateExec: mode=Partial, gby=[t2_id@0 as t2_id, a as Utf8("a")], aggr=[SUM(t2.t2_int)]
--------------------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id group by t2_id, 'a') as t2_sum from t1
----
11 3
22 1
33 NULL
44 3

# aggregated_correlated_scalar_subquery_with_having
query TT
explain SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id having sum(t2_int) < 3) as t2_sum from t1
----
logical_plan
Projection: t1.t1_id, __scalar_sq_8.SUM(t2.t2_int) AS t2_sum
--Left Join: t1.t1_id = __scalar_sq_8.t2_id
----TableScan: t1 projection=[t1_id]
----SubqueryAlias: __scalar_sq_8
------Projection: SUM(t2.t2_int), t2.t2_id
--------Filter: SUM(t2.t2_int) < Int64(3)
----------Aggregate: groupBy=[[t2.t2_id]], aggr=[[SUM(t2.t2_int)]]
------------TableScan: t2 projection=[t2_id, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, SUM(t2.t2_int)@1 as t2_sum]
--CoalesceBatchesExec: target_batch_size=8192
----HashJoinExec: mode=Partitioned, join_type=Left, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 1 })]
------CoalesceBatchesExec: target_batch_size=8192
--------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 4), input_partitions=4
----------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]
------ProjectionExec: expr=[SUM(t2.t2_int)@1 as SUM(t2.t2_int), t2_id@0 as t2_id]
--------CoalesceBatchesExec: target_batch_size=8192
----------FilterExec: SUM(t2.t2_int)@1 < 3
------------AggregateExec: mode=FinalPartitioned, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int)]
--------------CoalesceBatchesExec: target_batch_size=8192
----------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 4), input_partitions=4
------------------AggregateExec: mode=Partial, gby=[t2_id@0 as t2_id], aggr=[SUM(t2.t2_int)]
--------------------MemoryExec: partitions=4, partition_sizes=[1, 0, 0, 0]

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id having sum(t2_int) < 3) as t2_sum from t1
----
11 NULL
22 1
33 NULL
44 NULL


statement ok
set datafusion.explain.logical_plan_only = true;

# correlated_recursive_scalar_subquery
query TT
explain select c_custkey from customer
where c_acctbal < (
    select sum(o_totalprice) from orders
    where o_custkey = c_custkey
    and o_totalprice < (
            select sum(l_extendedprice) as price from lineitem where l_orderkey = o_orderkey
    )
) order by c_custkey;
----
logical_plan
Sort: customer.c_custkey ASC NULLS LAST
--Projection: customer.c_custkey
----Inner Join: customer.c_custkey = __scalar_sq_10.o_custkey Filter: CAST(customer.c_acctbal AS Decimal128(25, 2)) < __scalar_sq_10.SUM(orders.o_totalprice)
------TableScan: customer projection=[c_custkey, c_acctbal]
------SubqueryAlias: __scalar_sq_10
--------Projection: SUM(orders.o_totalprice), orders.o_custkey
----------Aggregate: groupBy=[[orders.o_custkey]], aggr=[[SUM(orders.o_totalprice)]]
------------Projection: orders.o_custkey, orders.o_totalprice
--------------Inner Join: orders.o_orderkey = __scalar_sq_11.l_orderkey Filter: CAST(orders.o_totalprice AS Decimal128(25, 2)) < __scalar_sq_11.price
----------------TableScan: orders projection=[o_orderkey, o_custkey, o_totalprice]
----------------SubqueryAlias: __scalar_sq_11
------------------Projection: SUM(lineitem.l_extendedprice) AS price, lineitem.l_orderkey
--------------------Aggregate: groupBy=[[lineitem.l_orderkey]], aggr=[[SUM(lineitem.l_extendedprice)]]
----------------------TableScan: lineitem projection=[l_orderkey, l_extendedprice]

# correlated_where_in
query TT
explain select o_orderkey from orders
where o_orderstatus in (
    select l_linestatus from lineitem where l_orderkey = orders.o_orderkey
);
----
logical_plan
Projection: orders.o_orderkey
--LeftSemi Join: orders.o_orderstatus = __correlated_sq_6.l_linestatus, orders.o_orderkey = __correlated_sq_6.l_orderkey
----TableScan: orders projection=[o_orderkey, o_orderstatus]
----SubqueryAlias: __correlated_sq_6
------Projection: lineitem.l_linestatus, lineitem.l_orderkey
--------TableScan: lineitem projection=[l_orderkey, l_linestatus]

query I rowsort
select o_orderkey from orders
where o_orderstatus in (
    select l_linestatus from lineitem where l_orderkey = orders.o_orderkey
);
----
2
3

#exists_subquery_with_same_table
#Subquery and outer query refer to the same table.
#It will not be rewritten to join because it is not a correlated subquery.
query TT
explain SELECT t1_id, t1_name, t1_int FROM t1 WHERE EXISTS(SELECT t1_int FROM t1 WHERE t1.t1_id > t1.t1_int)
----
logical_plan
Filter: EXISTS (<subquery>)
--Subquery:
----Projection: t1.t1_int
------Filter: t1.t1_id > t1.t1_int
--------TableScan: t1
--TableScan: t1 projection=[t1_id, t1_name, t1_int]


#in_subquery_with_same_table
#Subquery and outer query refer to the same table.
#It will be rewritten to join because in-subquery has extra predicate(`t1.t1_id = __correlated_sq_10.t1_int`).
query TT
explain SELECT t1_id, t1_name, t1_int FROM t1 WHERE t1_id IN(SELECT t1_int FROM t1 WHERE t1.t1_id > t1.t1_int)
----
logical_plan
LeftSemi Join: t1.t1_id = __correlated_sq_10.t1_int
--TableScan: t1 projection=[t1_id, t1_name, t1_int]
--SubqueryAlias: __correlated_sq_10
----Projection: t1.t1_int
------Filter: t1.t1_id > t1.t1_int
--------TableScan: t1 projection=[t1_id, t1_int]

#in_subquery_nested_exist_subquery
query TT
explain SELECT t1_id, t1_name, t1_int FROM t1 WHERE t1_id IN(SELECT t2_id FROM t2 WHERE EXISTS(select * from t1 WHERE t1.t1_int > t2.t2_int))
----
logical_plan
LeftSemi Join: t1.t1_id = __correlated_sq_11.t2_id
--TableScan: t1 projection=[t1_id, t1_name, t1_int]
--SubqueryAlias: __correlated_sq_11
----Projection: t2.t2_id
------LeftSemi Join:  Filter: __correlated_sq_12.t1_int > t2.t2_int
--------TableScan: t2 projection=[t2_id, t2_int]
--------SubqueryAlias: __correlated_sq_12
----------TableScan: t1 projection=[t1_int]

#invalid_scalar_subquery
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: Scalar subquery should only return one column, but found 2: t2.t2_id, t2.t2_name
SELECT t1_id, t1_name, t1_int, (select t2_id, t2_name FROM t2 WHERE t2.t2_id = t1.t1_int) FROM t1

#subquery_not_allowed
#In/Exist Subquery is not allowed in ORDER BY clause.
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: In/Exist subquery can only be used in Projection, Filter, Window functions, Aggregate and Join plan nodes
SELECT t1_id, t1_name, t1_int FROM t1 order by t1_int in (SELECT t2_int FROM t2 WHERE t1.t1_id > t1.t1_int)

#non_aggregated_correlated_scalar_subquery
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: Correlated scalar subquery must be aggregated to return at most one row
SELECT t1_id, (SELECT t2_int FROM t2 WHERE t2.t2_int = t1.t1_int) as t2_int from t1

statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: Correlated scalar subquery must be aggregated to return at most one row
SELECT t1_id, (SELECT t2_int FROM t2 WHERE t2.t2_int = t1_int group by t2_int) as t2_int from t1

#non_aggregated_correlated_scalar_subquery_with_limit
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: Correlated scalar subquery must be aggregated to return at most one row
SELECT t1_id, (SELECT t2_int FROM t2 WHERE t2.t2_int = t1.t1_int limit 2) as t2_int from t1

#non_aggregated_correlated_scalar_subquery_with_single_row
query TT
explain SELECT t1_id, (SELECT t2_int FROM t2 WHERE t2.t2_int = t1.t1_int limit 1) as t2_int from t1
----
logical_plan
Projection: t1.t1_id, (<subquery>) AS t2_int
--Subquery:
----Limit: skip=0, fetch=1
------Projection: t2.t2_int
--------Filter: t2.t2_int = outer_ref(t1.t1_int)
----------TableScan: t2
--TableScan: t1 projection=[t1_id]

query TT
explain SELECT t1_id from t1 where t1_int = (SELECT t2_int FROM t2 WHERE t2.t2_int = t1.t1_int limit 1)
----
logical_plan
Projection: t1.t1_id
--Filter: t1.t1_int = (<subquery>)
----Subquery:
------Limit: skip=0, fetch=1
--------Projection: t2.t2_int
----------Filter: t2.t2_int = outer_ref(t1.t1_int)
------------TableScan: t2
----TableScan: t1 projection=[t1_id, t1_int]

query TT
explain SELECT t1_id, (SELECT a FROM (select 1 as a) WHERE a = t1.t1_int) as t2_int from t1
----
logical_plan
Projection: t1.t1_id, __scalar_sq_16.a AS t2_int
--Left Join: CAST(t1.t1_int AS Int64) = __scalar_sq_16.a
----TableScan: t1 projection=[t1_id, t1_int]
----SubqueryAlias: __scalar_sq_16
------Projection: Int64(1) AS a
--------EmptyRelation

query II rowsort
SELECT t1_id, (SELECT a FROM (select 1 as a) WHERE a = t1.t1_int) as t2_int from t1
----
11 1
22 NULL
33 NULL
44 NULL

#non_equal_correlated_scalar_subquery
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: Correlated column is not allowed in predicate: t2\.t2_id < outer_ref\(t1\.t1_id\)
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id < t1.t1_id) as t2_sum from t1

#aggregated_correlated_scalar_subquery_with_extra_group_by_columns
statement error DataFusion error: check_analyzed_plan\ncaused by\nError during planning: A GROUP BY clause in a scalar correlated subquery cannot contain non-correlated columns
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id group by t2_name) as t2_sum from t1